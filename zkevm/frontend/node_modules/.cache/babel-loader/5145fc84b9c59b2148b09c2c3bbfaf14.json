{"ast":null,"code":"const assert = require('assert');\nconst levelup = require('levelup');\nconst memdown = require('memdown');\nconst async = require('async');\nconst rlp = require('rlp');\nconst ethUtil = require('ethereumjs-util');\nconst semaphore = require('semaphore');\nconst TrieNode = require('./trieNode');\nconst ReadStream = require('./readStream');\nconst PrioritizedTaskExecutor = require('./prioritizedTaskExecutor');\nconst matchingNibbleLength = require('./util').matchingNibbleLength;\nconst doKeysMatch = require('./util').doKeysMatch;\nconst callTogether = require('./util').callTogether;\nconst asyncFirstSeries = require('./util').asyncFirstSeries;\nmodule.exports = Trie;\n\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root]` A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\nfunction Trie(db, root) {\n  var self = this;\n  this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP;\n  this.sem = semaphore(1);\n\n  // setup dbs\n  this.db = db || levelup('', {\n    db: memdown\n  });\n  this._getDBs = [this.db];\n  this._putDBs = [this.db];\n  Object.defineProperty(this, 'root', {\n    set: function (value) {\n      if (value) {\n        value = ethUtil.toBuffer(value);\n        assert(value.length === 32, 'Invalid root length. Roots are 32 bytes');\n      } else {\n        value = self.EMPTY_TRIE_ROOT;\n      }\n      this._root = value;\n    },\n    get: function () {\n      return this._root;\n    }\n  });\n  this.root = root;\n}\n\n/**\n * Gets a value given a `key`\n * @method get\n * @param {Buffer|String} key - the key to search for\n * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n */\nTrie.prototype.get = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  self.findPath(key, function (err, node, remainder, stack) {\n    var value = null;\n    if (node && remainder.length === 0) {\n      value = node.value;\n    }\n    cb(err, value);\n  });\n};\n\n/**\n * Stores a given `value` at the given `key`\n * @method put\n * @param {Buffer|String} key\n * @param {Buffer|String} Value\n * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.put = function (key, value, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  value = ethUtil.toBuffer(value);\n  if (!value || value.toString() === '') {\n    self.del(key, cb);\n  } else {\n    cb = callTogether(cb, self.sem.leave);\n    self.sem.take(function () {\n      if (self.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n        // first try to find the give key or its nearst node\n        self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err);\n          }\n          // then update\n          self._updateNode(key, value, keyRemainder, stack, cb);\n        });\n      } else {\n        self._createInitialNode(key, value, cb); // if no root initialize this trie\n      }\n    });\n  }\n};\n\n/**\n * deletes a value given a `key`\n * @method del\n * @param {Buffer|String} key\n * @param {Function} callback the callback `Function`\n */\nTrie.prototype.del = function (key, cb) {\n  var self = this;\n  key = ethUtil.toBuffer(key);\n  cb = callTogether(cb, self.sem.leave);\n  self.sem.take(function () {\n    self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n      if (err) {\n        return cb(err);\n      }\n      if (foundValue) {\n        self._deleteNode(key, stack, cb);\n      } else {\n        cb();\n      }\n    });\n  });\n};\n\n/**\n * Retrieves a raw value in the underlying db\n * @method getRaw\n * @param {Buffer} key\n * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n */\nTrie.prototype.getRaw = function (key, cb) {\n  key = ethUtil.toBuffer(key);\n  function dbGet(db, cb2) {\n    db.get(key, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, function (err, foundNode) {\n      if (err || !foundNode) {\n        cb2(null, null);\n      } else {\n        cb2(null, foundNode);\n      }\n    });\n  }\n  asyncFirstSeries(this._getDBs, dbGet, cb);\n};\n\n// retrieves a node from dbs by hash\nTrie.prototype._lookupNode = function (node, cb) {\n  if (TrieNode.isRawNode(node)) {\n    cb(new TrieNode(node));\n  } else {\n    this.getRaw(node, function (err, value) {\n      if (err) {\n        throw err;\n      }\n      if (value) {\n        value = new TrieNode(rlp.decode(value));\n      }\n      cb(value);\n    });\n  }\n};\n\n// TODO: remove the proxy method when changing the caching\nTrie.prototype._putRaw = function (key, val, cb) {\n  function dbPut(db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2);\n  }\n  async.each(this._putDBs, dbPut, cb);\n};\n\n/**\n * Writes a value directly to the underlining db\n * @method putRaw\n * @param {Buffer|String} key The key as a `Buffer` or `String`\n * @param {Buffer} value The value to be stored\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.putRaw = Trie.prototype._putRaw;\n\n/**\n * Removes a raw value in the underlying db\n * @method delRaw\n * @param {Buffer|String} key\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.delRaw = function (key, cb) {\n  function del(db, cb2) {\n    db.del(key, {\n      keyEncoding: 'binary'\n    }, cb2);\n  }\n  async.each(this._putDBs, del, cb);\n};\n\n// writes a single node to dbs\nTrie.prototype._putNode = function (node, cb) {\n  var hash = node.hash();\n  var serialized = node.serialize();\n  this._putRaw(hash, serialized, cb);\n};\n\n// writes many nodes to db\nTrie.prototype._batchNodes = function (opStack, cb) {\n  function dbBatch(db, cb) {\n    db.batch(opStack, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb);\n  }\n  async.each(this._putDBs, dbBatch, cb);\n};\n\n/**\n * Trys to find a path to the node for the given key\n * It returns a `stack` of nodes to the closet node\n * @method findPath\n * @param {String|Buffer} - key - the search key\n * @param {Function} - cb - the callback function. Its is given the following\n * arguments\n *  - err - any errors encontered\n *  - node - the last node found\n *  - keyRemainder - the remaining key nibbles not accounted for\n *  - stack - an array of nodes that forms the path to node we are searching for\n */\n\nTrie.prototype.findPath = function (targetKey, cb) {\n  var self = this;\n  var root = self.root;\n  var stack = [];\n  targetKey = TrieNode.stringToNibbles(targetKey);\n  this._walkTrie(root, processNode, cb);\n  function processNode(nodeRef, node, keyProgress, walkController) {\n    var nodeKey = node.key || [];\n    var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey));\n    var matchingLen = matchingNibbleLength(keyRemainder, nodeKey);\n    stack.push(node);\n    if (node.type === 'branch') {\n      if (keyRemainder.length === 0) {\n        walkController.return(null, node, [], stack);\n        // we exhausted the key without finding a node\n      } else {\n        var branchIndex = keyRemainder[0];\n        var branchNode = node.getValue(branchIndex);\n        if (!branchNode) {\n          // there are no more nodes to find and we didn't find the key\n          walkController.return(null, null, keyRemainder, stack);\n        } else {\n          // node found, continuing search\n          walkController.only(branchIndex);\n        }\n      }\n    } else if (node.type === 'leaf') {\n      if (doKeysMatch(keyRemainder, nodeKey)) {\n        // keys match, return node with empty key\n        walkController.return(null, node, [], stack);\n      } else {\n        // reached leaf but keys dont match\n        walkController.return(null, null, keyRemainder, stack);\n      }\n    } else if (node.type === 'extention') {\n      if (matchingLen !== nodeKey.length) {\n        // keys dont match, fail\n        walkController.return(null, null, keyRemainder, stack);\n      } else {\n        // keys match, continue search\n        walkController.next();\n      }\n    }\n  }\n};\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findNode = function (key, root, stack, cb) {\n  this.findPath(key, function () {\n    cb.apply(null, arguments);\n  });\n};\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findValueNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    var fullKey = key;\n    if (node.key) {\n      fullKey = key.concat(node.key);\n    }\n    if (node.type === 'leaf') {\n      // found leaf node!\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else if (node.type === 'branch' && node.value) {\n      // found branch with value\n      onFound(nodeRef, node, fullKey, walkController.next);\n    } else {\n      // keep looking for value nodes\n      walkController.next();\n    }\n  }, cb);\n};\n\n/*\n * Finds all nodes that are stored directly in the db\n * (some nodes are stored raw inside other nodes)\n */\nTrie.prototype._findDbNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    if (TrieNode.isRawNode(nodeRef)) {\n      walkController.next();\n    } else {\n      onFound(nodeRef, node, key, walkController.next);\n    }\n  }, cb);\n};\n\n/**\n * Updates a node\n * @method _updateNode\n * @param {Buffer} key\n * @param {Buffer| String} value\n * @param {Array} keyRemainder\n * @param {Array} stack -\n * @param {Function} cb - the callback\n */\nTrie.prototype._updateNode = function (key, value, keyRemainder, stack, cb) {\n  var toSave = [];\n  var lastNode = stack.pop();\n\n  // add the new nodes\n  key = TrieNode.stringToNibbles(key);\n\n  // Check if the last node is a leaf and the key matches to this\n  var matchLeaf = false;\n  if (lastNode.type === 'leaf') {\n    var l = 0;\n    for (var i = 0; i < stack.length; i++) {\n      var n = stack[i];\n      if (n.type === 'branch') {\n        l++;\n      } else {\n        l += n.key.length;\n      }\n    }\n    if (matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length && keyRemainder.length === 0) {\n      matchLeaf = true;\n    }\n  }\n  if (matchLeaf) {\n    // just updating a found value\n    lastNode.value = value;\n    stack.push(lastNode);\n  } else if (lastNode.type === 'branch') {\n    stack.push(lastNode);\n    if (keyRemainder !== 0) {\n      // add an extention to a branch node\n      keyRemainder.shift();\n      // create a new leaf\n      var newLeaf = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeaf);\n    } else {\n      lastNode.value = value;\n    }\n  } else {\n    // create a branch node\n    var lastKey = lastNode.key;\n    var matchingLength = matchingNibbleLength(lastKey, keyRemainder);\n    var newBranchNode = new TrieNode('branch');\n\n    // create a new extention node\n    if (matchingLength !== 0) {\n      var newKey = lastNode.key.slice(0, matchingLength);\n      var newExtNode = new TrieNode('extention', newKey, value);\n      stack.push(newExtNode);\n      lastKey.splice(0, matchingLength);\n      keyRemainder.splice(0, matchingLength);\n    }\n    stack.push(newBranchNode);\n    if (lastKey.length !== 0) {\n      var branchKey = lastKey.shift();\n      if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n        // shriking extention or leaf\n        lastNode.key = lastKey;\n        var formatedNode = this._formatNode(lastNode, false, toSave);\n        newBranchNode.setValue(branchKey, formatedNode);\n      } else {\n        // remove extention or attaching\n        this._formatNode(lastNode, false, true, toSave);\n        newBranchNode.setValue(branchKey, lastNode.value);\n      }\n    } else {\n      newBranchNode.value = lastNode.value;\n    }\n    if (keyRemainder.length !== 0) {\n      keyRemainder.shift();\n      // add a leaf node to the new branch node\n      var newLeafNode = new TrieNode('leaf', keyRemainder, value);\n      stack.push(newLeafNode);\n    } else {\n      newBranchNode.value = value;\n    }\n  }\n  this._saveStack(key, stack, toSave, cb);\n};\n\n// walk tree\n\nTrie.prototype._walkTrie = function (root, onNode, onDone) {\n  var self = this;\n  root = root || self.root;\n  onDone = onDone || function () {};\n  var aborted = false;\n  var returnValues = [];\n  if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n    return onDone();\n  }\n  self._lookupNode(root, function (node) {\n    processNode(root, node, null, function (err) {\n      if (err) {\n        return onDone(err);\n      }\n      onDone.apply(null, returnValues);\n    });\n  });\n\n  // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n  // low enough to utilize the prioritisation of node lookup.\n  var maxPoolSize = 500;\n  var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize);\n  function processNode(nodeRef, node, key, cb) {\n    if (!node) return cb();\n    if (aborted) return cb();\n    var stopped = false;\n    key = key || [];\n    var walkController = {\n      stop: function () {\n        stopped = true;\n        cb();\n      },\n      // end all traversal and return values to the onDone cb\n      return: function () {\n        aborted = true;\n        returnValues = arguments;\n        cb();\n      },\n      next: function () {\n        if (aborted) {\n          return cb();\n        }\n        if (stopped) {\n          return cb();\n        }\n        var children = node.getChildren();\n        async.forEachOf(children, function (childData, index, cb) {\n          var keyExtension = childData[0];\n          var childRef = childData[1];\n          var childKey = key.concat(keyExtension);\n          var priority = childKey.length;\n          taskExecutor.execute(priority, function (taskCallback) {\n            self._lookupNode(childRef, function (childNode) {\n              taskCallback();\n              processNode(childRef, childNode, childKey, cb);\n            });\n          });\n        }, cb);\n      },\n      only: function (childIndex) {\n        var childRef = node.getValue(childIndex);\n        var childKey = key.slice();\n        childKey.push(childIndex);\n        var priority = childKey.length;\n        taskExecutor.execute(priority, function (taskCallback) {\n          self._lookupNode(childRef, function (childNode) {\n            taskCallback();\n            processNode(childRef, childNode, childKey, cb);\n          });\n        });\n      }\n    };\n    onNode(nodeRef, node, key, walkController);\n  }\n};\n\n/**\n * saves a stack\n * @method _saveStack\n * @param {Array} key - the key. Should follow the stack\n * @param {Array} stack - a stack of nodes to the value given by the key\n * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n * @param {Function} cb\n */\nTrie.prototype._saveStack = function (key, stack, opStack, cb) {\n  var lastRoot;\n\n  // update nodes\n  while (stack.length) {\n    var node = stack.pop();\n    if (node.type === 'leaf') {\n      key.splice(key.length - node.key.length);\n    } else if (node.type === 'extention') {\n      key.splice(key.length - node.key.length);\n      if (lastRoot) {\n        node.value = lastRoot;\n      }\n    } else if (node.type === 'branch') {\n      if (lastRoot) {\n        var branchKey = key.pop();\n        node.setValue(branchKey, lastRoot);\n      }\n    }\n    lastRoot = this._formatNode(node, stack.length === 0, opStack);\n  }\n  if (lastRoot) {\n    this.root = lastRoot;\n  }\n  this._batchNodes(opStack, cb);\n};\nTrie.prototype._deleteNode = function (key, stack, cb) {\n  function processBranchNode(key, branchKey, branchNode, parentNode, stack) {\n    // branchNode is the node ON the branch node not THE branch node\n    var branchNodeKey = branchNode.key;\n    if (!parentNode || parentNode.type === 'branch') {\n      // branch->?\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n      if (branchNode.type === 'branch') {\n        // create an extention node\n        // branch->extention->branch\n        var extentionNode = new TrieNode('extention', [branchKey], null);\n        stack.push(extentionNode);\n        key.push(branchKey);\n      } else {\n        // branch key is an extention or a leaf\n        // branch->(leaf or extention)\n        branchNodeKey.unshift(branchKey);\n        branchNode.key = branchNodeKey;\n\n        // hackery. This is equvilant to array.concat except we need keep the\n        // rerfance to the `key` that was passed in.\n        branchNodeKey.unshift(0);\n        branchNodeKey.unshift(key.length);\n        key.splice.apply(key, branchNodeKey);\n      }\n      stack.push(branchNode);\n    } else {\n      // parent is a extention\n      var parentKey = parentNode.key;\n      if (branchNode.type === 'branch') {\n        // ext->branch\n        parentKey.push(branchKey);\n        key.push(branchKey);\n        parentNode.key = parentKey;\n        stack.push(parentNode);\n      } else {\n        // branch node is an leaf or extention and parent node is an exstention\n        // add two keys together\n        // dont push the parent node\n        branchNodeKey.unshift(branchKey);\n        key = key.concat(branchNodeKey);\n        parentKey = parentKey.concat(branchNodeKey);\n        branchNode.key = parentKey;\n      }\n      stack.push(branchNode);\n    }\n    return key;\n  }\n  var lastNode = stack.pop();\n  var parentNode = stack.pop();\n  var opStack = [];\n  var self = this;\n  if (!Array.isArray(key)) {\n    // convert key to nibbles\n    key = TrieNode.stringToNibbles(key);\n  }\n  if (!parentNode) {\n    // the root here has to be a leaf.\n    this.root = this.EMPTY_TRIE_ROOT;\n    cb();\n  } else {\n    if (lastNode.type === 'branch') {\n      lastNode.value = null;\n    } else {\n      // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n      // if it has one must be a branch.\n      var lastNodeKey = lastNode.key;\n      key.splice(key.length - lastNodeKey.length);\n      // delete the value\n      this._formatNode(lastNode, false, true, opStack);\n      parentNode.setValue(key.pop(), null);\n      lastNode = parentNode;\n      parentNode = stack.pop();\n    }\n\n    // nodes on the branch\n    var branchNodes = [];\n    // count the number of nodes on the branch\n    lastNode.raw.forEach(function (node, i) {\n      var val = lastNode.getValue(i);\n      if (val) branchNodes.push([i, val]);\n    });\n\n    // if there is only one branch node left, collapse the branch node\n    if (branchNodes.length === 1) {\n      // add the one remaing branch node to node above it\n      var branchNode = branchNodes[0][1];\n      var branchNodeKey = branchNodes[0][0];\n\n      // look up node\n      this._lookupNode(branchNode, function (foundNode) {\n        key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack);\n        self._saveStack(key, stack, opStack, cb);\n      });\n    } else {\n      // simple removing a leaf and recaluclation the stack\n      if (parentNode) {\n        stack.push(parentNode);\n      }\n      stack.push(lastNode);\n      self._saveStack(key, stack, opStack, cb);\n    }\n  }\n};\n\n// Creates the initial node from an empty tree\nTrie.prototype._createInitialNode = function (key, value, cb) {\n  var newNode = new TrieNode('leaf', key, value);\n  this.root = newNode.hash();\n  this._putNode(newNode, cb);\n};\n\n// formats node to be saved by levelup.batch.\n// returns either the hash that will be used key or the rawNode\nTrie.prototype._formatNode = function (node, topLevel, remove, opStack) {\n  if (arguments.length === 3) {\n    opStack = remove;\n    remove = false;\n  }\n  var rlpNode = node.serialize();\n  if (rlpNode.length >= 32 || topLevel) {\n    var hashRoot = node.hash();\n    if (remove && this.isCheckpoint) {\n      opStack.push({\n        type: 'del',\n        key: hashRoot\n      });\n    } else {\n      opStack.push({\n        type: 'put',\n        key: hashRoot,\n        value: rlpNode\n      });\n    }\n    return hashRoot;\n  }\n  return node.raw;\n};\n\n/**\n * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n * @method createReadStream\n * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n */\nTrie.prototype.createReadStream = function () {\n  return new ReadStream(this);\n};\n\n// creates a new trie backed by the same db\n// and starting at the same root\nTrie.prototype.copy = function () {\n  return new Trie(this.db, this.root);\n};\n\n/**\n * The given hash of operations (key additions or deletions) are executed on the DB\n * @method batch\n * @example\n * var ops = [\n *    { type: 'del', key: 'father' }\n *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n *  , { type: 'put', key: 'occupation', value: 'Clown' }\n * ]\n * trie.batch(ops)\n * @param {Array} ops\n * @param {Function} cb\n */\nTrie.prototype.batch = function (ops, cb) {\n  var self = this;\n  async.eachSeries(ops, function (op, cb2) {\n    if (op.type === 'put') {\n      self.put(op.key, op.value, cb2);\n    } else if (op.type === 'del') {\n      self.del(op.key, cb2);\n    } else {\n      cb2();\n    }\n  }, cb);\n};\n\n/**\n * Checks if a given root exists\n * @method checkRoot\n * @param {Buffer} root\n * @param {Function} cb\n */\nTrie.prototype.checkRoot = function (root, cb) {\n  root = ethUtil.toBuffer(root);\n  this._lookupNode(root, function (value) {\n    cb(null, !!value);\n  });\n};","map":{"version":3,"names":["assert","require","levelup","memdown","async","rlp","ethUtil","semaphore","TrieNode","ReadStream","PrioritizedTaskExecutor","matchingNibbleLength","doKeysMatch","callTogether","asyncFirstSeries","module","exports","Trie","db","root","self","EMPTY_TRIE_ROOT","SHA3_RLP","sem","_getDBs","_putDBs","Object","defineProperty","set","value","toBuffer","length","_root","get","prototype","key","cb","findPath","err","node","remainder","stack","put","toString","del","leave","take","foundValue","keyRemainder","_updateNode","_createInitialNode","_deleteNode","getRaw","dbGet","cb2","keyEncoding","valueEncoding","foundNode","_lookupNode","isRawNode","decode","_putRaw","val","dbPut","each","putRaw","delRaw","_putNode","hash","serialized","serialize","_batchNodes","opStack","dbBatch","batch","targetKey","stringToNibbles","_walkTrie","processNode","nodeRef","keyProgress","walkController","nodeKey","slice","matchingLen","push","type","return","branchIndex","branchNode","getValue","only","next","_findNode","apply","arguments","_findValueNodes","onFound","fullKey","concat","_findDbNodes","toSave","lastNode","pop","matchLeaf","l","i","n","shift","newLeaf","lastKey","matchingLength","newBranchNode","newKey","newExtNode","splice","branchKey","formatedNode","_formatNode","setValue","newLeafNode","_saveStack","onNode","onDone","aborted","returnValues","maxPoolSize","taskExecutor","stopped","stop","children","getChildren","forEachOf","childData","index","keyExtension","childRef","childKey","priority","execute","taskCallback","childNode","childIndex","lastRoot","processBranchNode","parentNode","branchNodeKey","extentionNode","unshift","parentKey","Array","isArray","lastNodeKey","branchNodes","raw","forEach","newNode","topLevel","remove","rlpNode","hashRoot","isCheckpoint","createReadStream","copy","ops","eachSeries","op","checkRoot"],"sources":["/home/tiptape/relearningculture/zkevm/frontend/node_modules/merkle-patricia-tree/baseTrie.js"],"sourcesContent":["const assert = require('assert')\nconst levelup = require('levelup')\nconst memdown = require('memdown')\nconst async = require('async')\nconst rlp = require('rlp')\nconst ethUtil = require('ethereumjs-util')\nconst semaphore = require('semaphore')\nconst TrieNode = require('./trieNode')\nconst ReadStream = require('./readStream')\nconst PrioritizedTaskExecutor = require('./prioritizedTaskExecutor')\nconst matchingNibbleLength = require('./util').matchingNibbleLength\nconst doKeysMatch = require('./util').doKeysMatch\nconst callTogether = require('./util').callTogether\nconst asyncFirstSeries = require('./util').asyncFirstSeries\n\nmodule.exports = Trie\n\n/**\n * Use `require('merkel-patricia-tree')` for the base interface. In Ethereum applications stick with the Secure Trie Overlay `require('merkel-patricia-tree/secure')`. The API for the raw and the secure interface are about the same\n * @class Trie\n * @param {Object} [db] An instance of [levelup](https://github.com/rvagg/node-levelup/) or a compatible API. If the db is `null` or left undefined, then the trie will be stored in memory via [memdown](https://github.com/rvagg/memdown)\n * @param {Buffer|String} [root]` A hex `String` or `Buffer` for the root of a previously stored trie\n * @prop {Buffer} root The current root of the `trie`\n * @prop {Boolean} isCheckpoint  determines if you are saving to a checkpoint or directly to the db\n * @prop {Buffer} EMPTY_TRIE_ROOT the Root for an empty trie\n */\nfunction Trie (db, root) {\n  var self = this\n  this.EMPTY_TRIE_ROOT = ethUtil.SHA3_RLP\n  this.sem = semaphore(1)\n\n  // setup dbs\n  this.db = db ||\n    levelup('', {\n      db: memdown\n    })\n\n  this._getDBs = [this.db]\n  this._putDBs = [this.db]\n\n  Object.defineProperty(this, 'root', {\n    set: function (value) {\n      if (value) {\n        value = ethUtil.toBuffer(value)\n        assert(value.length === 32, 'Invalid root length. Roots are 32 bytes')\n      } else {\n        value = self.EMPTY_TRIE_ROOT\n      }\n\n      this._root = value\n    },\n    get: function () {\n      return this._root\n    }\n  })\n\n  this.root = root\n}\n\n/**\n * Gets a value given a `key`\n * @method get\n * @param {Buffer|String} key - the key to search for\n * @param {Function} cb A callback `Function` which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`\n */\nTrie.prototype.get = function (key, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n\n  self.findPath(key, function (err, node, remainder, stack) {\n    var value = null\n    if (node && remainder.length === 0) {\n      value = node.value\n    }\n\n    cb(err, value)\n  })\n}\n\n/**\n * Stores a given `value` at the given `key`\n * @method put\n * @param {Buffer|String} key\n * @param {Buffer|String} Value\n * @param {Function} cb A callback `Function` which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.put = function (key, value, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n  value = ethUtil.toBuffer(value)\n\n  if (!value || value.toString() === '') {\n    self.del(key, cb)\n  } else {\n    cb = callTogether(cb, self.sem.leave)\n\n    self.sem.take(function () {\n      if (self.root.toString('hex') !== ethUtil.SHA3_RLP.toString('hex')) {\n        // first try to find the give key or its nearst node\n        self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n          if (err) {\n            return cb(err)\n          }\n          // then update\n          self._updateNode(key, value, keyRemainder, stack, cb)\n        })\n      } else {\n        self._createInitialNode(key, value, cb) // if no root initialize this trie\n      }\n    })\n  }\n}\n\n/**\n * deletes a value given a `key`\n * @method del\n * @param {Buffer|String} key\n * @param {Function} callback the callback `Function`\n */\nTrie.prototype.del = function (key, cb) {\n  var self = this\n\n  key = ethUtil.toBuffer(key)\n  cb = callTogether(cb, self.sem.leave)\n\n  self.sem.take(function () {\n    self.findPath(key, function (err, foundValue, keyRemainder, stack) {\n      if (err) {\n        return cb(err)\n      }\n      if (foundValue) {\n        self._deleteNode(key, stack, cb)\n      } else {\n        cb()\n      }\n    })\n  })\n}\n\n/**\n * Retrieves a raw value in the underlying db\n * @method getRaw\n * @param {Buffer} key\n * @param {Function} callback A callback `Function`, which is given the arguments `err` - for errors that may have occured and `value` - the found value in a `Buffer` or if no value was found `null`.\n */\nTrie.prototype.getRaw = function (key, cb) {\n  key = ethUtil.toBuffer(key)\n\n  function dbGet (db, cb2) {\n    db.get(key, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, function (err, foundNode) {\n      if (err || !foundNode) {\n        cb2(null, null)\n      } else {\n        cb2(null, foundNode)\n      }\n    })\n  }\n  asyncFirstSeries(this._getDBs, dbGet, cb)\n}\n\n// retrieves a node from dbs by hash\nTrie.prototype._lookupNode = function (node, cb) {\n  if (TrieNode.isRawNode(node)) {\n    cb(new TrieNode(node))\n  } else {\n    this.getRaw(node, function (err, value) {\n      if (err) {\n        throw err\n      }\n\n      if (value) {\n        value = new TrieNode(rlp.decode(value))\n      }\n\n      cb(value)\n    })\n  }\n}\n\n// TODO: remove the proxy method when changing the caching\nTrie.prototype._putRaw = function (key, val, cb) {\n  function dbPut (db, cb2) {\n    db.put(key, val, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb2)\n  }\n  async.each(this._putDBs, dbPut, cb)\n}\n\n/**\n * Writes a value directly to the underlining db\n * @method putRaw\n * @param {Buffer|String} key The key as a `Buffer` or `String`\n * @param {Buffer} value The value to be stored\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.putRaw = Trie.prototype._putRaw\n\n/**\n * Removes a raw value in the underlying db\n * @method delRaw\n * @param {Buffer|String} key\n * @param {Function} callback A callback `Function`, which is given the argument `err` - for errors that may have occured\n */\nTrie.prototype.delRaw = function (key, cb) {\n  function del (db, cb2) {\n    db.del(key, {\n      keyEncoding: 'binary'\n    }, cb2)\n  }\n  async.each(this._putDBs, del, cb)\n}\n\n// writes a single node to dbs\nTrie.prototype._putNode = function (node, cb) {\n  var hash = node.hash()\n  var serialized = node.serialize()\n  this._putRaw(hash, serialized, cb)\n}\n\n// writes many nodes to db\nTrie.prototype._batchNodes = function (opStack, cb) {\n  function dbBatch (db, cb) {\n    db.batch(opStack, {\n      keyEncoding: 'binary',\n      valueEncoding: 'binary'\n    }, cb)\n  }\n\n  async.each(this._putDBs, dbBatch, cb)\n}\n\n/**\n * Trys to find a path to the node for the given key\n * It returns a `stack` of nodes to the closet node\n * @method findPath\n * @param {String|Buffer} - key - the search key\n * @param {Function} - cb - the callback function. Its is given the following\n * arguments\n *  - err - any errors encontered\n *  - node - the last node found\n *  - keyRemainder - the remaining key nibbles not accounted for\n *  - stack - an array of nodes that forms the path to node we are searching for\n */\n\nTrie.prototype.findPath = function (targetKey, cb) {\n  var self = this\n  var root = self.root\n  var stack = []\n  targetKey = TrieNode.stringToNibbles(targetKey)\n\n  this._walkTrie(root, processNode, cb)\n\n  function processNode (nodeRef, node, keyProgress, walkController) {\n    var nodeKey = node.key || []\n    var keyRemainder = targetKey.slice(matchingNibbleLength(keyProgress, targetKey))\n    var matchingLen = matchingNibbleLength(keyRemainder, nodeKey)\n\n    stack.push(node)\n\n    if (node.type === 'branch') {\n      if (keyRemainder.length === 0) {\n        walkController.return(null, node, [], stack)\n      // we exhausted the key without finding a node\n      } else {\n        var branchIndex = keyRemainder[0]\n        var branchNode = node.getValue(branchIndex)\n        if (!branchNode) {\n          // there are no more nodes to find and we didn't find the key\n          walkController.return(null, null, keyRemainder, stack)\n        } else {\n          // node found, continuing search\n          walkController.only(branchIndex)\n        }\n      }\n    } else if (node.type === 'leaf') {\n      if (doKeysMatch(keyRemainder, nodeKey)) {\n        // keys match, return node with empty key\n        walkController.return(null, node, [], stack)\n      } else {\n        // reached leaf but keys dont match\n        walkController.return(null, null, keyRemainder, stack)\n      }\n    } else if (node.type === 'extention') {\n      if (matchingLen !== nodeKey.length) {\n        // keys dont match, fail\n        walkController.return(null, null, keyRemainder, stack)\n      } else {\n        // keys match, continue search\n        walkController.next()\n      }\n    }\n  }\n}\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findNode = function (key, root, stack, cb) {\n  this.findPath(key, function () {\n    cb.apply(null, arguments)\n  })\n}\n\n/*\n * Finds all nodes that store k,v values\n */\nTrie.prototype._findValueNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    var fullKey = key\n\n    if (node.key) {\n      fullKey = key.concat(node.key)\n    }\n\n    if (node.type === 'leaf') {\n      // found leaf node!\n      onFound(nodeRef, node, fullKey, walkController.next)\n    } else if (node.type === 'branch' && node.value) {\n      // found branch with value\n      onFound(nodeRef, node, fullKey, walkController.next)\n    } else {\n      // keep looking for value nodes\n      walkController.next()\n    }\n  }, cb)\n}\n\n/*\n * Finds all nodes that are stored directly in the db\n * (some nodes are stored raw inside other nodes)\n */\nTrie.prototype._findDbNodes = function (onFound, cb) {\n  this._walkTrie(this.root, function (nodeRef, node, key, walkController) {\n    if (TrieNode.isRawNode(nodeRef)) {\n      walkController.next()\n    } else {\n      onFound(nodeRef, node, key, walkController.next)\n    }\n  }, cb)\n}\n\n/**\n * Updates a node\n * @method _updateNode\n * @param {Buffer} key\n * @param {Buffer| String} value\n * @param {Array} keyRemainder\n * @param {Array} stack -\n * @param {Function} cb - the callback\n */\nTrie.prototype._updateNode = function (key, value, keyRemainder, stack, cb) {\n  var toSave = []\n  var lastNode = stack.pop()\n\n  // add the new nodes\n  key = TrieNode.stringToNibbles(key)\n\n  // Check if the last node is a leaf and the key matches to this\n  var matchLeaf = false\n  if (lastNode.type === 'leaf') {\n    var l = 0\n    for (var i = 0; i < stack.length; i++) {\n      var n = stack[i]\n      if (n.type === 'branch') {\n        l++\n      } else {\n        l += n.key.length\n      }\n    }\n    if ((matchingNibbleLength(lastNode.key, key.slice(l)) === lastNode.key.length) && (keyRemainder.length === 0)) {\n      matchLeaf = true\n    }\n  }\n\n  if (matchLeaf) {\n    // just updating a found value\n    lastNode.value = value\n    stack.push(lastNode)\n  } else if (lastNode.type === 'branch') {\n    stack.push(lastNode)\n    if (keyRemainder !== 0) {\n      // add an extention to a branch node\n      keyRemainder.shift()\n      // create a new leaf\n      var newLeaf = new TrieNode('leaf', keyRemainder, value)\n      stack.push(newLeaf)\n    } else {\n      lastNode.value = value\n    }\n  } else {\n    // create a branch node\n    var lastKey = lastNode.key\n    var matchingLength = matchingNibbleLength(lastKey, keyRemainder)\n    var newBranchNode = new TrieNode('branch')\n\n    // create a new extention node\n    if (matchingLength !== 0) {\n      var newKey = lastNode.key.slice(0, matchingLength)\n      var newExtNode = new TrieNode('extention', newKey, value)\n      stack.push(newExtNode)\n      lastKey.splice(0, matchingLength)\n      keyRemainder.splice(0, matchingLength)\n    }\n\n    stack.push(newBranchNode)\n\n    if (lastKey.length !== 0) {\n      var branchKey = lastKey.shift()\n      if (lastKey.length !== 0 || lastNode.type === 'leaf') {\n        // shriking extention or leaf\n        lastNode.key = lastKey\n        var formatedNode = this._formatNode(lastNode, false, toSave)\n        newBranchNode.setValue(branchKey, formatedNode)\n      } else {\n        // remove extention or attaching\n        this._formatNode(lastNode, false, true, toSave)\n        newBranchNode.setValue(branchKey, lastNode.value)\n      }\n    } else {\n      newBranchNode.value = lastNode.value\n    }\n\n    if (keyRemainder.length !== 0) {\n      keyRemainder.shift()\n      // add a leaf node to the new branch node\n      var newLeafNode = new TrieNode('leaf', keyRemainder, value)\n      stack.push(newLeafNode)\n    } else {\n      newBranchNode.value = value\n    }\n  }\n\n  this._saveStack(key, stack, toSave, cb)\n}\n\n// walk tree\n\nTrie.prototype._walkTrie = function (root, onNode, onDone) {\n  var self = this\n  root = root || self.root\n  onDone = onDone || function () {}\n  var aborted = false\n  var returnValues = []\n\n  if (root.toString('hex') === ethUtil.SHA3_RLP.toString('hex')) {\n    return onDone()\n  }\n\n  self._lookupNode(root, function (node) {\n    processNode(root, node, null, function (err) {\n      if (err) {\n        return onDone(err)\n      }\n      onDone.apply(null, returnValues)\n    })\n  })\n\n  // the maximum pool size should be high enough to utilise the parallelizability of reading nodes from disk and\n  // low enough to utilize the prioritisation of node lookup.\n  var maxPoolSize = 500\n  var taskExecutor = new PrioritizedTaskExecutor(maxPoolSize)\n\n  function processNode (nodeRef, node, key, cb) {\n    if (!node) return cb()\n    if (aborted) return cb()\n    var stopped = false\n    key = key || []\n\n    var walkController = {\n      stop: function () {\n        stopped = true\n        cb()\n      },\n      // end all traversal and return values to the onDone cb\n      return: function () {\n        aborted = true\n        returnValues = arguments\n        cb()\n      },\n      next: function () {\n        if (aborted) {\n          return cb()\n        }\n        if (stopped) {\n          return cb()\n        }\n        var children = node.getChildren()\n        async.forEachOf(children, function (childData, index, cb) {\n          var keyExtension = childData[0]\n          var childRef = childData[1]\n          var childKey = key.concat(keyExtension)\n          var priority = childKey.length\n          taskExecutor.execute(priority, function (taskCallback) {\n            self._lookupNode(childRef, function (childNode) {\n              taskCallback()\n              processNode(childRef, childNode, childKey, cb)\n            })\n          })\n        }, cb)\n      },\n      only: function (childIndex) {\n        var childRef = node.getValue(childIndex)\n        var childKey = key.slice()\n        childKey.push(childIndex)\n        var priority = childKey.length\n        taskExecutor.execute(priority, function (taskCallback) {\n          self._lookupNode(childRef, function (childNode) {\n            taskCallback()\n            processNode(childRef, childNode, childKey, cb)\n          })\n        })\n      }\n    }\n    onNode(nodeRef, node, key, walkController)\n  }\n}\n\n/**\n * saves a stack\n * @method _saveStack\n * @param {Array} key - the key. Should follow the stack\n * @param {Array} stack - a stack of nodes to the value given by the key\n * @param {Array} opStack - a stack of levelup operations to commit at the end of this funciton\n * @param {Function} cb\n */\nTrie.prototype._saveStack = function (key, stack, opStack, cb) {\n  var lastRoot\n\n  // update nodes\n  while (stack.length) {\n    var node = stack.pop()\n    if (node.type === 'leaf') {\n      key.splice(key.length - node.key.length)\n    } else if (node.type === 'extention') {\n      key.splice(key.length - node.key.length)\n      if (lastRoot) {\n        node.value = lastRoot\n      }\n    } else if (node.type === 'branch') {\n      if (lastRoot) {\n        var branchKey = key.pop()\n        node.setValue(branchKey, lastRoot)\n      }\n    }\n    lastRoot = this._formatNode(node, stack.length === 0, opStack)\n  }\n\n  if (lastRoot) {\n    this.root = lastRoot\n  }\n\n  this._batchNodes(opStack, cb)\n}\n\nTrie.prototype._deleteNode = function (key, stack, cb) {\n  function processBranchNode (key, branchKey, branchNode, parentNode, stack) {\n    // branchNode is the node ON the branch node not THE branch node\n    var branchNodeKey = branchNode.key\n    if (!parentNode || parentNode.type === 'branch') {\n      // branch->?\n      if (parentNode) {\n        stack.push(parentNode)\n      }\n\n      if (branchNode.type === 'branch') {\n        // create an extention node\n        // branch->extention->branch\n        var extentionNode = new TrieNode('extention', [branchKey], null)\n        stack.push(extentionNode)\n        key.push(branchKey)\n      } else {\n        // branch key is an extention or a leaf\n        // branch->(leaf or extention)\n        branchNodeKey.unshift(branchKey)\n        branchNode.key = branchNodeKey\n\n        // hackery. This is equvilant to array.concat except we need keep the\n        // rerfance to the `key` that was passed in.\n        branchNodeKey.unshift(0)\n        branchNodeKey.unshift(key.length)\n        key.splice.apply(key, branchNodeKey)\n      }\n      stack.push(branchNode)\n    } else {\n      // parent is a extention\n      var parentKey = parentNode.key\n      if (branchNode.type === 'branch') {\n        // ext->branch\n        parentKey.push(branchKey)\n        key.push(branchKey)\n        parentNode.key = parentKey\n        stack.push(parentNode)\n      } else {\n        // branch node is an leaf or extention and parent node is an exstention\n        // add two keys together\n        // dont push the parent node\n        branchNodeKey.unshift(branchKey)\n        key = key.concat(branchNodeKey)\n        parentKey = parentKey.concat(branchNodeKey)\n        branchNode.key = parentKey\n      }\n      stack.push(branchNode)\n    }\n\n    return key\n  }\n\n  var lastNode = stack.pop()\n  var parentNode = stack.pop()\n  var opStack = []\n  var self = this\n\n  if (!Array.isArray(key)) {\n    // convert key to nibbles\n    key = TrieNode.stringToNibbles(key)\n  }\n\n  if (!parentNode) {\n    // the root here has to be a leaf.\n    this.root = this.EMPTY_TRIE_ROOT\n    cb()\n  } else {\n    if (lastNode.type === 'branch') {\n      lastNode.value = null\n    } else {\n      // the lastNode has to be a leaf if its not a branch. And a leaf's parent\n      // if it has one must be a branch.\n      var lastNodeKey = lastNode.key\n      key.splice(key.length - lastNodeKey.length)\n      // delete the value\n      this._formatNode(lastNode, false, true, opStack)\n      parentNode.setValue(key.pop(), null)\n      lastNode = parentNode\n      parentNode = stack.pop()\n    }\n\n    // nodes on the branch\n    var branchNodes = []\n    // count the number of nodes on the branch\n    lastNode.raw.forEach(function (node, i) {\n      var val = lastNode.getValue(i)\n      if (val) branchNodes.push([i, val])\n    })\n\n    // if there is only one branch node left, collapse the branch node\n    if (branchNodes.length === 1) {\n      // add the one remaing branch node to node above it\n      var branchNode = branchNodes[0][1]\n      var branchNodeKey = branchNodes[0][0]\n\n      // look up node\n      this._lookupNode(branchNode, function (foundNode) {\n        key = processBranchNode(key, branchNodeKey, foundNode, parentNode, stack, opStack)\n        self._saveStack(key, stack, opStack, cb)\n      })\n    } else {\n      // simple removing a leaf and recaluclation the stack\n      if (parentNode) {\n        stack.push(parentNode)\n      }\n\n      stack.push(lastNode)\n      self._saveStack(key, stack, opStack, cb)\n    }\n  }\n}\n\n// Creates the initial node from an empty tree\nTrie.prototype._createInitialNode = function (key, value, cb) {\n  var newNode = new TrieNode('leaf', key, value)\n  this.root = newNode.hash()\n  this._putNode(newNode, cb)\n}\n\n// formats node to be saved by levelup.batch.\n// returns either the hash that will be used key or the rawNode\nTrie.prototype._formatNode = function (node, topLevel, remove, opStack) {\n  if (arguments.length === 3) {\n    opStack = remove\n    remove = false\n  }\n\n  var rlpNode = node.serialize()\n  if (rlpNode.length >= 32 || topLevel) {\n    var hashRoot = node.hash()\n\n    if (remove && this.isCheckpoint) {\n      opStack.push({\n        type: 'del',\n        key: hashRoot\n      })\n    } else {\n      opStack.push({\n        type: 'put',\n        key: hashRoot,\n        value: rlpNode\n      })\n    }\n    return hashRoot\n  }\n  return node.raw\n}\n\n/**\n * The `data` event is given an `Object` hat has two properties; the `key` and the `value`. Both should be Buffers.\n * @method createReadStream\n * @return {stream.Readable} Returns a [stream](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_class_stream_readable) of the contents of the `trie`\n */\nTrie.prototype.createReadStream = function () {\n  return new ReadStream(this)\n}\n\n// creates a new trie backed by the same db\n// and starting at the same root\nTrie.prototype.copy = function () {\n  return new Trie(this.db, this.root)\n}\n\n/**\n * The given hash of operations (key additions or deletions) are executed on the DB\n * @method batch\n * @example\n * var ops = [\n *    { type: 'del', key: 'father' }\n *  , { type: 'put', key: 'name', value: 'Yuri Irsenovich Kim' }\n *  , { type: 'put', key: 'dob', value: '16 February 1941' }\n *  , { type: 'put', key: 'spouse', value: 'Kim Young-sook' }\n *  , { type: 'put', key: 'occupation', value: 'Clown' }\n * ]\n * trie.batch(ops)\n * @param {Array} ops\n * @param {Function} cb\n */\nTrie.prototype.batch = function (ops, cb) {\n  var self = this\n\n  async.eachSeries(ops, function (op, cb2) {\n    if (op.type === 'put') {\n      self.put(op.key, op.value, cb2)\n    } else if (op.type === 'del') {\n      self.del(op.key, cb2)\n    } else {\n      cb2()\n    }\n  }, cb)\n}\n\n/**\n * Checks if a given root exists\n * @method checkRoot\n * @param {Buffer} root\n * @param {Function} cb\n */\nTrie.prototype.checkRoot = function (root, cb) {\n  root = ethUtil.toBuffer(root)\n  this._lookupNode(root, function (value) {\n    cb(null, !!value)\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}