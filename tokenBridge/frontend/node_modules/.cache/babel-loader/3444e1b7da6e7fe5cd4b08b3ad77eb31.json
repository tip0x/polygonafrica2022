{"ast":null,"code":"const TrieNode = require('./trieNode');\nconst ethUtil = require('ethereumjs-util');\nconst matchingNibbleLength = require('./util').matchingNibbleLength;\n\n/**\n * Returns a merkle proof for a given key\n * @method Trie.prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\nexports.prove = function (trie, key, cb) {\n  var nodes;\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err);\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'));\n    nodes = stack;\n    var p = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize();\n      if (rlpNode.length >= 32 || i === 0) {\n        p.push(rlpNode);\n      }\n    }\n    cb(null, p);\n  });\n};\n\n/**\n * Verifies a merkle proof for a given key\n * @method Trie.verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key);\n  var wantHash = ethUtil.toBuffer(rootHash);\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i]);\n    var hash = ethUtil.sha3(proof[i]);\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'));\n    }\n    var node = new TrieNode(ethUtil.rlp.decode(p));\n    var cld;\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'));\n        }\n        return cb(null, node.value);\n      }\n      cld = node.raw[key[0]];\n      key = key.slice(1);\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld);\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'));\n        }\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'));\n        }\n        key = key.slice(embeddedNode.key.length);\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'));\n        }\n        return cb(null, embeddedNode.value);\n      } else {\n        wantHash = cld;\n      }\n    } else if (node.type === 'extention' || node.type === 'leaf') {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'));\n      }\n      cld = node.value;\n      key = key.slice(node.key.length);\n      if (key.length === 0 || cld.length === 17 && key.length === 1) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1];\n          key = key.slice(1);\n        }\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'));\n        }\n        return cb(null, cld);\n      } else {\n        wantHash = cld;\n      }\n    } else {\n      return cb(new Error('Invalid node type'));\n    }\n  }\n  cb(new Error('Unexpected end of proof'));\n};","map":{"version":3,"names":["TrieNode","require","ethUtil","matchingNibbleLength","exports","prove","trie","key","cb","nodes","findPath","err","node","remaining","stack","length","Error","p","i","rlpNode","serialize","push","verifyProof","rootHash","proof","stringToNibbles","wantHash","toBuffer","hash","sha3","Buffer","compare","rlp","decode","cld","type","value","raw","slice","embeddedNode"],"sources":["/home/tiptape/relearningculture/zkevm/frontend/node_modules/merkle-patricia-tree/proof.js"],"sourcesContent":["const TrieNode = require('./trieNode')\nconst ethUtil = require('ethereumjs-util')\nconst matchingNibbleLength = require('./util').matchingNibbleLength\n\n/**\n * Returns a merkle proof for a given key\n * @method Trie.prove\n * @param {Trie} trie\n * @param {String} key\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {Array.<TrieNode>} `proof`)\n */\nexports.prove = function (trie, key, cb) {\n  var nodes\n\n  trie.findPath(key, function (err, node, remaining, stack) {\n    if (err) return cb(err)\n    if (remaining.length > 0) return cb(new Error('Node does not contain the key'))\n    nodes = stack\n    var p = []\n    for (var i = 0; i < nodes.length; i++) {\n      var rlpNode = nodes[i].serialize()\n\n      if ((rlpNode.length >= 32) || (i === 0)) {\n        p.push(rlpNode)\n      }\n    }\n    cb(null, p)\n  })\n}\n\n/**\n * Verifies a merkle proof for a given key\n * @method Trie.verifyProof\n * @param {Buffer} rootHash\n * @param {String} key\n * @param {Array.<TrieNode>} proof\n * @param {Function} cb A callback `Function` (arguments {Error} `err`, {String} `val`)\n */\nexports.verifyProof = function (rootHash, key, proof, cb) {\n  key = TrieNode.stringToNibbles(key)\n  var wantHash = ethUtil.toBuffer(rootHash)\n  for (var i = 0; i < proof.length; i++) {\n    var p = ethUtil.toBuffer(proof[i])\n    var hash = ethUtil.sha3(proof[i])\n    if (Buffer.compare(hash, wantHash)) {\n      return cb(new Error('Bad proof node ' + i + ': hash mismatch'))\n    }\n    var node = new TrieNode(ethUtil.rlp.decode(p))\n    var cld\n    if (node.type === 'branch') {\n      if (key.length === 0) {\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (branch)'))\n        }\n        return cb(null, node.value)\n      }\n      cld = node.raw[key[0]]\n      key = key.slice(1)\n      if (cld.length === 2) {\n        var embeddedNode = new TrieNode(cld)\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (embeddedNode)'))\n        }\n\n        if (matchingNibbleLength(embeddedNode.key, key) !== embeddedNode.key.length) {\n          return cb(new Error('Key length does not match with the proof one (embeddedNode)'))\n        }\n        key = key.slice(embeddedNode.key.length)\n        if (key.length !== 0) {\n          return cb(new Error('Key does not match with the proof one (embeddedNode)'))\n        }\n        return cb(null, embeddedNode.value)\n      } else {\n        wantHash = cld\n      }\n    } else if ((node.type === 'extention') || (node.type === 'leaf')) {\n      if (matchingNibbleLength(node.key, key) !== node.key.length) {\n        return cb(new Error('Key does not match with the proof one (extention|leaf)'))\n      }\n      cld = node.value\n      key = key.slice(node.key.length)\n      if (key.length === 0 || (cld.length === 17 && key.length === 1)) {\n        // The value is in an embedded branch. Extract it.\n        if (cld.length === 17) {\n          cld = cld[key[0]][1]\n          key = key.slice(1)\n        }\n        if (i !== proof.length - 1) {\n          return cb(new Error('Additional nodes at end of proof (extention|leaf)'))\n        }\n        return cb(null, cld)\n      } else {\n        wantHash = cld\n      }\n    } else {\n      return cb(new Error('Invalid node type'))\n    }\n  }\n  cb(new Error('Unexpected end of proof'))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}