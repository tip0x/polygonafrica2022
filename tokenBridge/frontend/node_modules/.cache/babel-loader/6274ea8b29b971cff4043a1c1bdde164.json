{"ast":null,"code":"const {\n  Buffer\n} = require('buffer');\nconst ethUtil = require('ethereumjs-util');\nconst ethAbi = require('ethereumjs-abi');\nconst nacl = require('tweetnacl');\nnacl.util = require('tweetnacl-util');\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [this.hashType(primaryType, types)];\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value === null || value === undefined ? '0x0000000000000000000000000000000000000000000000000000000000000000' : ethUtil.keccak(this.encodeData(type, value, types, useV4))];\n        }\n        if (value === undefined) {\n          throw new Error(`missing value for field ${name} of type ${type}`);\n        }\n        if (type === 'bytes') {\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['));\n          const typeValuePairs = value.map(item => encodeField(name, parsedType, item));\n          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(_ref => {\n            let [_type] = _ref;\n            return _type;\n          }), typeValuePairs.map(_ref2 => {\n            let [, _value] = _ref2;\n            return _value;\n          })))];\n        }\n        return [type, value];\n      };\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name]);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name];\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32');\n            value = ethUtil.keccak(value);\n            encodedValues.push(value);\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32');\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8');\n            }\n            value = ethUtil.keccak(value);\n            encodedValues.push(value);\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32');\n            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4));\n            encodedValues.push(value);\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData');\n          } else {\n            encodedTypes.push(field.type);\n            encodedValues.push(value);\n          }\n        }\n      }\n    }\n    return ethAbi.rawEncode(encodedTypes, encodedValues);\n  },\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType(primaryType, types) {\n    let result = '';\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType);\n    deps = [primaryType].concat(deps.sort());\n    for (const type of deps) {\n      const children = types[type];\n      if (!children) {\n        throw new Error(`No type definition specified: ${type}`);\n      }\n      result += `${type}(${types[type].map(_ref3 => {\n        let {\n          name,\n          type: _type\n        } = _ref3;\n        return `${_type} ${name}`;\n      }).join(',')})`;\n    }\n    return result;\n  },\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies(primaryType, types) {\n    let results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const [firstWord] = primaryType.match(/^\\w*/u);\n    primaryType = firstWord;\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n    results.push(primaryType);\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep);\n      }\n    }\n    return results;\n  },\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));\n  },\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType(primaryType, types) {\n    return ethUtil.keccak(this.encodeType(primaryType, types));\n  },\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData(data) {\n    const sanitizedData = {};\n    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {\n      data[key] && (sanitizedData[key] = data[key]);\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = {\n        EIP712Domain: [],\n        ...sanitizedData.types\n      };\n    }\n    return sanitizedData;\n  },\n  /**\n   * Signs a typed message as per EIP-712 and returns its keccak hash\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - keccak hash of the resulting signed message\n   */\n  sign(typedData) {\n    let useV4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const sanitizedData = this.sanitizeData(typedData);\n    const parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n    return ethUtil.keccak(Buffer.concat(parts));\n  }\n};\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n  concatSig(v, r, s) {\n    const rSig = ethUtil.fromSigned(r);\n    const sSig = ethUtil.fromSigned(s);\n    const vSig = ethUtil.bufferToInt(v);\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');\n  },\n  normalize(input) {\n    if (!input) {\n      return undefined;\n    }\n    if (typeof input === 'number') {\n      const buffer = ethUtil.toBuffer(input);\n      input = ethUtil.bufferToHex(buffer);\n    }\n    if (typeof input !== 'string') {\n      let msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n      msg += ` received ${typeof input}: ${input}`;\n      throw new Error(msg);\n    }\n    return ethUtil.addHexPrefix(input.toLowerCase());\n  },\n  personalSign(privateKey, msgParams) {\n    const message = ethUtil.toBuffer(msgParams.data);\n    const msgHash = ethUtil.hashPersonalMessage(message);\n    const sig = ethUtil.ecsign(msgHash, privateKey);\n    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n    return serialized;\n  },\n  recoverPersonalSignature(msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    const sender = ethUtil.publicToAddress(publicKey);\n    const senderHex = ethUtil.bufferToHex(sender);\n    return senderHex;\n  },\n  extractPublicKey(msgParams) {\n    const publicKey = getPublicKeyFor(msgParams);\n    return `0x${publicKey.toString('hex')}`;\n  },\n  typedSignatureHash(typedData) {\n    const hashBuffer = typedSignatureHash(typedData);\n    return ethUtil.bufferToHex(hashBuffer);\n  },\n  signTypedDataLegacy(privateKey, msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const sig = ethUtil.ecsign(msgHash, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignatureLegacy(msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data);\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  encrypt(receiverPublicKey, msgParams, version) {\n    switch (version) {\n      case 'x25519-xsalsa20-poly1305':\n        {\n          if (typeof msgParams.data === 'undefined') {\n            throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ');\n          }\n          // generate ephemeral keypair\n          const ephemeralKeyPair = nacl.box.keyPair();\n\n          // assemble encryption parameters - from string to UInt8\n          let pubKeyUInt8Array;\n          try {\n            pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey);\n          } catch (err) {\n            throw new Error('Bad public key');\n          }\n          const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data);\n          const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n          // encrypt\n          const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);\n\n          // handle encrypted data\n          const output = {\n            version: 'x25519-xsalsa20-poly1305',\n            nonce: nacl.util.encodeBase64(nonce),\n            ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),\n            ciphertext: nacl.util.encodeBase64(encryptedMessage)\n          };\n          // return encrypted msg data\n          return output;\n        }\n      default:\n        throw new Error('Encryption type/version not supported');\n    }\n  },\n  encryptSafely(receiverPublicKey, msgParams, version) {\n    const DEFAULT_PADDING_LENGTH = 2 ** 11;\n    const NACL_EXTRA_BYTES = 16;\n    const {\n      data\n    } = msgParams;\n    if (!data) {\n      throw new Error('Cannot encrypt empty msg.data');\n    }\n    if (typeof data === 'object' && data.toJSON) {\n      // remove toJSON attack vector\n      // TODO, check all possible children\n      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    }\n\n    // add padding\n    const dataWithPadding = {\n      data,\n      padding: ''\n    };\n\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    let padLength = 0;\n    // Only pad if necessary\n    if (modVal > 0) {\n      padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n\n    dataWithPadding.padding = '0'.repeat(padLength);\n    const paddedMsgParams = {\n      data: JSON.stringify(dataWithPadding)\n    };\n    return this.encrypt(receiverPublicKey, paddedMsgParams, version);\n  },\n  decrypt(encryptedData, receiverPrivateKey) {\n    switch (encryptedData.version) {\n      case 'x25519-xsalsa20-poly1305':\n        {\n          // string to buffer to UInt8Array\n          const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);\n          const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;\n\n          // assemble decryption parameters\n          const nonce = nacl.util.decodeBase64(encryptedData.nonce);\n          const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext);\n          const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey);\n\n          // decrypt\n          const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);\n\n          // return decrypted msg data\n          let output;\n          try {\n            output = nacl.util.encodeUTF8(decryptedMessage);\n          } catch (err) {\n            throw new Error('Decryption failed.');\n          }\n          if (output) {\n            return output;\n          }\n          throw new Error('Decryption failed.');\n        }\n      default:\n        throw new Error('Encryption type/version not supported.');\n    }\n  },\n  decryptSafely(encryptedData, receiverPrivateKey) {\n    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey));\n    return dataWithPadding.data;\n  },\n  getEncryptionPublicKey(privateKey) {\n    const privateKeyUint8Array = nacl_decodeHex(privateKey);\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return nacl.util.encodeBase64(encryptionPublicKey);\n  },\n  /**\n   * A generic entry point for all typed data methods to be passed, includes a version parameter.\n   */\n  signTypedMessage(privateKey, msgParams) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'V4';\n    switch (version) {\n      case 'V1':\n        return this.signTypedDataLegacy(privateKey, msgParams);\n      case 'V3':\n        return this.signTypedData(privateKey, msgParams);\n      case 'V4':\n      default:\n        return this.signTypedData_v4(privateKey, msgParams);\n    }\n  },\n  recoverTypedMessage(msgParams) {\n    let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'V4';\n    switch (version) {\n      case 'V1':\n        return this.recoverTypedSignatureLegacy(msgParams);\n      case 'V3':\n        return this.recoverTypedSignature(msgParams);\n      case 'V4':\n      default:\n        return this.recoverTypedSignature_v4(msgParams);\n    }\n  },\n  signTypedData(privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false);\n    const sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  signTypedData_v4(privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data);\n    const sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignature(msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false);\n    const publicKey = recoverPublicKey(message, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  recoverTypedSignature_v4(msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data);\n    const publicKey = recoverPublicKey(message, msgParams.sig);\n    const sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  }\n};\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHash(typedData) {\n  const error = new Error('Expect argument to be non-empty array');\n  if (typeof typedData !== 'object' || !typedData.length) {\n    throw error;\n  }\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;\n  });\n  const types = typedData.map(function (e) {\n    return e.type;\n  });\n  const schema = typedData.map(function (e) {\n    if (!e.name) {\n      throw error;\n    }\n    return `${e.type} ${e.name}`;\n  });\n  return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema), ethAbi.soliditySHA3(types, data)]);\n}\nfunction recoverPublicKey(hash, sig) {\n  const signature = ethUtil.toBuffer(sig);\n  const sigParams = ethUtil.fromRpcSig(signature);\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);\n}\nfunction getPublicKeyFor(msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data);\n  const msgHash = ethUtil.hashPersonalMessage(message);\n  return recoverPublicKey(msgHash, msgParams.sig);\n}\nfunction padWithZeroes(number, length) {\n  let myString = `${number}`;\n  while (myString.length < length) {\n    myString = `0${myString}`;\n  }\n  return myString;\n}\n\n// converts hex strings to the Uint8Array format used by nacl\nfunction nacl_decodeHex(msgHex) {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return nacl.util.decodeBase64(msgBase64);\n}","map":{"version":3,"names":["Buffer","require","ethUtil","ethAbi","nacl","util","TYPED_MESSAGE_SCHEMA","type","properties","types","additionalProperties","items","name","required","primaryType","domain","message","TypedDataUtils","encodeData","data","useV4","encodedTypes","encodedValues","hashType","encodeField","value","undefined","keccak","Error","from","lastIndexOf","length","parsedType","slice","typeValuePairs","map","item","rawEncode","_type","_value","field","push","encodeType","result","deps","findTypeDependencies","filter","dep","concat","sort","children","join","results","firstWord","match","includes","hashStruct","sanitizeData","sanitizedData","key","Object","keys","EIP712Domain","sign","typedData","parts","module","exports","concatSig","v","r","s","rSig","fromSigned","sSig","vSig","bufferToInt","rStr","padWithZeroes","toUnsigned","toString","sStr","vStr","stripHexPrefix","intToHex","addHexPrefix","normalize","input","buffer","toBuffer","bufferToHex","msg","toLowerCase","personalSign","privateKey","msgParams","msgHash","hashPersonalMessage","sig","ecsign","serialized","recoverPersonalSignature","publicKey","getPublicKeyFor","sender","publicToAddress","senderHex","extractPublicKey","typedSignatureHash","hashBuffer","signTypedDataLegacy","recoverTypedSignatureLegacy","recoverPublicKey","encrypt","receiverPublicKey","version","ephemeralKeyPair","box","keyPair","pubKeyUInt8Array","decodeBase64","err","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","output","encodeBase64","ephemPublicKey","ciphertext","encryptSafely","DEFAULT_PADDING_LENGTH","NACL_EXTRA_BYTES","toJSON","dataWithPadding","padding","dataLength","byteLength","JSON","stringify","modVal","padLength","repeat","paddedMsgParams","decrypt","encryptedData","receiverPrivateKey","recieverPrivateKeyUint8Array","nacl_decodeHex","recieverEncryptionPrivateKey","fromSecretKey","decryptedMessage","open","encodeUTF8","decryptSafely","parse","getEncryptionPublicKey","privateKeyUint8Array","encryptionPublicKey","signTypedMessage","signTypedData","signTypedData_v4","recoverTypedMessage","recoverTypedSignature","recoverTypedSignature_v4","error","e","schema","soliditySHA3","Array","fill","hash","signature","sigParams","fromRpcSig","ecrecover","number","myString","msgHex","msgBase64"],"sources":["/home/tiptape/relearningculture/zkevm/frontend/node_modules/eth-sig-util/index.js"],"sourcesContent":["const { Buffer } = require('buffer')\nconst ethUtil = require('ethereumjs-util')\nconst ethAbi = require('ethereumjs-abi')\nconst nacl = require('tweetnacl')\nnacl.util = require('tweetnacl-util')\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: { type: 'string' },\n            type: { type: 'string' },\n          },\n          required: ['name', 'type'],\n        },\n      },\n    },\n    primaryType: { type: 'string' },\n    domain: { type: 'object' },\n    message: { type: 'object' },\n  },\n  required: ['types', 'primaryType', 'domain', 'message'],\n}\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData (primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32']\n    const encodedValues = [this.hashType(primaryType, types)]\n\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value === null || value === undefined ?\n            '0x0000000000000000000000000000000000000000000000000000000000000000' :\n            ethUtil.keccak(this.encodeData(type, value, types, useV4))]\n        }\n\n        if (value === undefined) {\n          throw new Error(`missing value for field ${name} of type ${type}`)\n        }\n\n        if (type === 'bytes') {\n          return ['bytes32', ethUtil.keccak(value)]\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8')\n          }\n          return ['bytes32', ethUtil.keccak(value)]\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['))\n          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))\n          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(\n            typeValuePairs.map(([_type]) => _type),\n            typeValuePairs.map(([, _value]) => _value),\n          ))]\n        }\n\n        return [type, value]\n      }\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name])\n        encodedTypes.push(type)\n        encodedValues.push(value)\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name]\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32')\n            value = ethUtil.keccak(value)\n            encodedValues.push(value)\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32')\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8')\n            }\n            value = ethUtil.keccak(value)\n            encodedValues.push(value)\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32')\n            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))\n            encodedValues.push(value)\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData')\n          } else {\n            encodedTypes.push(field.type)\n            encodedValues.push(value)\n          }\n        }\n      }\n    }\n\n    return ethAbi.rawEncode(encodedTypes, encodedValues)\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType (primaryType, types) {\n    let result = ''\n    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)\n    deps = [primaryType].concat(deps.sort())\n    for (const type of deps) {\n      const children = types[type]\n      if (!children) {\n        throw new Error(`No type definition specified: ${type}`)\n      }\n      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`\n    }\n    return result\n  },\n\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies (primaryType, types, results = []) {\n    const [firstWord] = primaryType.match(/^\\w*/u)\n    primaryType = firstWord\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results\n    }\n    results.push(primaryType)\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep)\n      }\n    }\n    return results\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct (primaryType, data, types, useV4 = true) {\n    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType (primaryType, types) {\n    return ethUtil.keccak(this.encodeType(primaryType, types))\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData (data) {\n    const sanitizedData = {}\n    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {\n      data[key] && (sanitizedData[key] = data[key])\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }\n    }\n    return sanitizedData\n  },\n\n  /**\n   * Signs a typed message as per EIP-712 and returns its keccak hash\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - keccak hash of the resulting signed message\n   */\n  sign (typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData)\n    const parts = [Buffer.from('1901', 'hex')]\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))\n    }\n    return ethUtil.keccak(Buffer.concat(parts))\n  },\n}\n\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n\n  concatSig (v, r, s) {\n    const rSig = ethUtil.fromSigned(r)\n    const sSig = ethUtil.fromSigned(s)\n    const vSig = ethUtil.bufferToInt(v)\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')\n  },\n\n  normalize (input) {\n    if (!input) {\n      return undefined\n    }\n\n    if (typeof input === 'number') {\n      const buffer = ethUtil.toBuffer(input)\n      input = ethUtil.bufferToHex(buffer)\n    }\n\n    if (typeof input !== 'string') {\n      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'\n      msg += ` received ${typeof input}: ${input}`\n      throw new Error(msg)\n    }\n\n    return ethUtil.addHexPrefix(input.toLowerCase())\n  },\n\n  personalSign (privateKey, msgParams) {\n    const message = ethUtil.toBuffer(msgParams.data)\n    const msgHash = ethUtil.hashPersonalMessage(message)\n    const sig = ethUtil.ecsign(msgHash, privateKey)\n    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n    return serialized\n  },\n\n  recoverPersonalSignature (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams)\n    const sender = ethUtil.publicToAddress(publicKey)\n    const senderHex = ethUtil.bufferToHex(sender)\n    return senderHex\n  },\n\n  extractPublicKey (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams)\n    return `0x${publicKey.toString('hex')}`\n  },\n\n  typedSignatureHash (typedData) {\n    const hashBuffer = typedSignatureHash(typedData)\n    return ethUtil.bufferToHex(hashBuffer)\n  },\n\n  signTypedDataLegacy (privateKey, msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data)\n    const sig = ethUtil.ecsign(msgHash, privateKey)\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n  },\n\n  recoverTypedSignatureLegacy (msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data)\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig)\n    const sender = ethUtil.publicToAddress(publicKey)\n    return ethUtil.bufferToHex(sender)\n  },\n\n  encrypt (receiverPublicKey, msgParams, version) {\n\n    switch (version) {\n      case 'x25519-xsalsa20-poly1305': {\n        if (typeof msgParams.data === 'undefined') {\n          throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ')\n        }\n        // generate ephemeral keypair\n        const ephemeralKeyPair = nacl.box.keyPair()\n\n        // assemble encryption parameters - from string to UInt8\n        let pubKeyUInt8Array\n        try {\n          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)\n        } catch (err) {\n          throw new Error('Bad public key')\n        }\n\n        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)\n        const nonce = nacl.randomBytes(nacl.box.nonceLength)\n\n        // encrypt\n        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)\n\n        // handle encrypted data\n        const output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: nacl.util.encodeBase64(nonce),\n          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: nacl.util.encodeBase64(encryptedMessage),\n        }\n        // return encrypted msg data\n        return output\n      }\n      default:\n        throw new Error('Encryption type/version not supported')\n\n    }\n  },\n\n  encryptSafely (receiverPublicKey, msgParams, version) {\n\n    const DEFAULT_PADDING_LENGTH = (2 ** 11)\n    const NACL_EXTRA_BYTES = 16\n\n    const { data } = msgParams\n    if (!data) {\n      throw new Error('Cannot encrypt empty msg.data')\n    }\n\n    if (typeof data === 'object' && data.toJSON) {\n      // remove toJSON attack vector\n      // TODO, check all possible children\n      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')\n    }\n\n    // add padding\n    const dataWithPadding = {\n      data,\n      padding: '',\n    }\n\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')\n    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)\n    let padLength = 0\n    // Only pad if necessary\n    if (modVal > 0) {\n      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes\n    }\n    dataWithPadding.padding = '0'.repeat(padLength)\n\n    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }\n    return this.encrypt(receiverPublicKey, paddedMsgParams, version)\n  },\n\n  decrypt (encryptedData, receiverPrivateKey) {\n\n    switch (encryptedData.version) {\n      case 'x25519-xsalsa20-poly1305': {\n        // string to buffer to UInt8Array\n        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)\n        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey\n\n        // assemble decryption parameters\n        const nonce = nacl.util.decodeBase64(encryptedData.nonce)\n        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)\n        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)\n\n        // decrypt\n        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)\n\n        // return decrypted msg data\n        let output\n        try {\n          output = nacl.util.encodeUTF8(decryptedMessage)\n        } catch (err) {\n          throw new Error('Decryption failed.')\n        }\n\n        if (output) {\n          return output\n        }\n        throw new Error('Decryption failed.')\n      }\n\n      default:\n        throw new Error('Encryption type/version not supported.')\n    }\n  },\n\n  decryptSafely (encryptedData, receiverPrivateKey) {\n    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))\n    return dataWithPadding.data\n  },\n\n\n  getEncryptionPublicKey (privateKey) {\n    const privateKeyUint8Array = nacl_decodeHex(privateKey)\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey\n    return nacl.util.encodeBase64(encryptionPublicKey)\n  },\n\n\n  /**\n   * A generic entry point for all typed data methods to be passed, includes a version parameter.\n   */\n  signTypedMessage (privateKey, msgParams, version = 'V4') {\n    switch (version) {\n      case 'V1':\n        return this.signTypedDataLegacy(privateKey, msgParams)\n      case 'V3':\n        return this.signTypedData(privateKey, msgParams)\n      case 'V4':\n      default:\n        return this.signTypedData_v4(privateKey, msgParams)\n    }\n  },\n\n  recoverTypedMessage (msgParams, version = 'V4') {\n    switch (version) {\n      case 'V1':\n        return this.recoverTypedSignatureLegacy(msgParams)\n      case 'V3':\n        return this.recoverTypedSignature(msgParams)\n      case 'V4':\n      default:\n        return this.recoverTypedSignature_v4(msgParams)\n    }\n  },\n\n  signTypedData (privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false)\n    const sig = ethUtil.ecsign(message, privateKey)\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n  },\n\n  signTypedData_v4 (privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data)\n    const sig = ethUtil.ecsign(message, privateKey)\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n  },\n\n  recoverTypedSignature (msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false)\n    const publicKey = recoverPublicKey(message, msgParams.sig)\n    const sender = ethUtil.publicToAddress(publicKey)\n    return ethUtil.bufferToHex(sender)\n  },\n\n  recoverTypedSignature_v4 (msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data)\n    const publicKey = recoverPublicKey(message, msgParams.sig)\n    const sender = ethUtil.publicToAddress(publicKey)\n    return ethUtil.bufferToHex(sender)\n  },\n\n}\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHash (typedData) {\n  const error = new Error('Expect argument to be non-empty array')\n  if (typeof typedData !== 'object' || !typedData.length) {\n    throw error\n  }\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value\n  })\n  const types = typedData.map(function (e) {\n    return e.type\n  })\n  const schema = typedData.map(function (e) {\n    if (!e.name) {\n      throw error\n    }\n    return `${e.type} ${e.name}`\n  })\n\n  return ethAbi.soliditySHA3(\n    ['bytes32', 'bytes32'],\n    [\n      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n      ethAbi.soliditySHA3(types, data),\n    ],\n  )\n}\n\nfunction recoverPublicKey (hash, sig) {\n  const signature = ethUtil.toBuffer(sig)\n  const sigParams = ethUtil.fromRpcSig(signature)\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)\n}\n\nfunction getPublicKeyFor (msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data)\n  const msgHash = ethUtil.hashPersonalMessage(message)\n  return recoverPublicKey(msgHash, msgParams.sig)\n}\n\n\nfunction padWithZeroes (number, length) {\n  let myString = `${number}`\n  while (myString.length < length) {\n    myString = `0${myString}`\n  }\n  return myString\n}\n\n// converts hex strings to the Uint8Array format used by nacl\nfunction nacl_decodeHex (msgHex) {\n  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')\n  return nacl.util.decodeBase64(msgBase64)\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}