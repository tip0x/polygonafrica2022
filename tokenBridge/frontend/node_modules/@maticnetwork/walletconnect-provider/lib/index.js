"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _browser = _interopRequireDefault(require("@walletconnect/browser"));

var _utils = require("@walletconnect/utils");

var _qrcodeModal = _interopRequireDefault(require("@walletconnect/qrcode-modal"));

/* eslint-env browser */
var XMLHttpRequest = null;
var sessionPromise = null;
var webconnector = null;
var walletconnectMethods = ['eth_signTransaction', 'eth_sendTransaction', 'eth_sign', 'eth_signTypedDataLegacy', 'eth_signTypedData', 'personal_sign']; // supported methods

var supportedMethods = ['eth_accounts'].concat(walletconnectMethods);

if (typeof window !== 'undefined' && window.XMLHttpRequest) {
  XMLHttpRequest = window.XMLHttpRequest;
} else {
  throw new Error('XMLHttpRequest not found');
}

function getCallback(payload, cb) {
  return function (err, result) {
    var obj = {};
    var keys = ['id', 'jsonrpc'];
    keys.forEach(function (key) {
      obj[key] = payload[key];
    });
    obj.result = result;
    cb(err, obj);
  };
}

var WalletConnectProvider =
/*#__PURE__*/
function () {
  function WalletConnectProvider(_ref) {
    var _ref$host = _ref.host,
        host = _ref$host === void 0 ? 'http://localhost:8545' : _ref$host,
        _ref$timeout = _ref.timeout,
        timeout = _ref$timeout === void 0 ? 0 : _ref$timeout,
        user = _ref.user,
        password = _ref.password,
        headers = _ref.headers,
        _ref$bridgeURL = _ref.bridgeURL,
        bridgeURL = _ref$bridgeURL === void 0 ? 'https://bridge.walletconnect.org' : _ref$bridgeURL,
        _ref$showQRCode = _ref.showQRCode,
        showQRCode = _ref$showQRCode === void 0 ? true : _ref$showQRCode,
        _ref$callbacks = _ref.callbacks,
        callbacks = _ref$callbacks === void 0 ? {} : _ref$callbacks;
    (0, _classCallCheck2.default)(this, WalletConnectProvider);
    this.host = host;
    this.timeout = timeout;
    this.user = user;
    this.password = password;
    this.headers = headers;
    this.bridgeURL = bridgeURL;
    this.connected = false;
    this.showQRCode = showQRCode;
    this.callbacks = callbacks;
  }
  /**
   * Should be called to prepare new XMLHttpRequest
   *
   * @method prepareRequest
   * @param {Boolean} true if request should be async
   * @return {XMLHttpRequest} object
   */


  (0, _createClass2.default)(WalletConnectProvider, [{
    key: "prepareRequest",
    value: function prepareRequest() {
      var isAsync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var request = new XMLHttpRequest();
      request.open('POST', this.host, isAsync);

      if (this.user && this.password) {
        var authString = Buffer.from(this.user + ':' + this.password).toString('base64');
        request.setRequestHeader('Authorization', "Basic ".concat(authString));
      }

      request.setRequestHeader('Content-Type', 'application/json'); // set headers

      if (this.headers) {
        this.headers.forEach(function (header) {
          request.setRequestHeader(header.name, header.value);
        });
      }

      return request;
    }
    /**
     * Should be called to make sync request
     *
     * @method send
     * @param {Object} payload
     * @return {Object} result
     */

  }, {
    key: "send",
    value: function send() {
      var payload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var request = this.prepareRequest(false);

      try {
        request.send(JSON.stringify(payload));
      } catch (error) {
        throw new Error("Invalid connection ".concat(this.host));
      }

      var result = request.responseText;

      try {
        result = JSON.parse(result);
      } catch (e) {
        throw new Error("Invalid response ".concat(request.responseText));
      }

      return result;
    }
  }, {
    key: "createWebconnector",
    value: function () {
      var _createWebconnector = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var _this = this;

        var d;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // create WebConnector
                webconnector = new _browser.default({
                  bridge: this.bridgeURL
                });

                if (webconnector.connected) {
                  _context.next = 4;
                  break;
                }

                d = new Promise(function (resolve, reject) {
                  // load connect
                  webconnector.on('connect', function (error, payload) {
                    if (error) {
                      return reject(error);
                    } // on connect callback


                    _this.callbacks.onConnect && _this.callbacks.onConnect(error, payload); // close qr code

                    if (_this.showQRCode) {
                      _qrcodeModal.default.close();
                    } // get provided accounts and chainId


                    var accounts = payload.params[0].accounts;
                    resolve(accounts);
                  });
                  webconnector.on('disconnect', function (error, payload) {
                    if (error) {
                      throw error;
                    } // on disconnect callback


                    _this.callbacks.onDisconnect && _this.callbacks.onDisconnect(error, payload); // close qr code

                    if (_this.showQRCode) {
                      _qrcodeModal.default.close();
                    }
                  });
                });
                return _context.abrupt("return", webconnector.createSession().then(function () {
                  // get uri for QR Code modal
                  var uri = webconnector.uri; // callback on session create

                  _this.callbacks.onCreate && _this.callbacks.onCreate(uri); // show qr code if asked

                  if (_this.showQRCode) {
                    // display QR Code modal
                    _qrcodeModal.default.open(uri, function () {
                      webconnector = null;
                      sessionPromise = null;
                      _this.callbacks.onAbort && _this.callbacks.onAbort(uri);
                    });
                  }
                }).then(function () {
                  return d;
                }).catch(function () {
                  webconnector = null;
                  sessionPromise = null;
                }));

              case 4:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  var _accounts = webconnector && webconnector.session && webconnector.session.accounts;

                  if (_accounts && _accounts.length) {
                    resolve(_accounts);
                  } else {
                    webconnector.on('session_update', function (error, payload) {
                      if (error) {
                        return reject(error);
                      } // on update


                      _this.callbacks.onUpdate && _this.callbacks.onUpdate(error, payload);
                      var accounts = payload.params[0].accounts;
                      resolve(accounts);
                    });
                  }
                }));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createWebconnector() {
        return _createWebconnector.apply(this, arguments);
      }

      return createWebconnector;
    }()
  }, {
    key: "_sendAsync",
    value: function _sendAsync(payload, callback) {
      var _this2 = this;

      var request = this.prepareRequest(true);

      request.onreadystatechange = function () {
        if (request.readyState === 4 && request.timeout !== 1) {
          var result = request.responseText;
          var error = null;

          try {
            result = JSON.parse(result);
          } catch (e) {
            error = new Error("Invalid response ".concat(request.responseText));
          }

          callback(error, result);
        }
      };

      request.ontimeout = function () {
        callback(new Error("Connection timeout ".concat(_this2.timeout)));
      };

      try {
        request.send(JSON.stringify(payload));
      } catch (error) {
        callback(new Error("Invalid connection ".concat(this.host)));
      }
    }
    /**
     * Should be used to make async request
     *
     * @method sendAsync
     * @param {Object} payload
     * @param {Function} callback triggered on end with (err, result)
     */

  }, {
    key: "sendAsync",
    value: function sendAsync(payload, callback) {
      var _this3 = this;

      var p = Promise.resolve();

      if (supportedMethods.includes(payload.method)) {
        if (!sessionPromise) {
          // create WebConnector
          sessionPromise = this.createWebconnector();
        }

        p = sessionPromise;

        if (walletconnectMethods.includes(payload.method)) {
          var fn = getCallback(payload, callback);

          if (payload.method === 'eth_sendTransaction') {
            payload.params.push((0, _utils.convertNumberToHex)(payload.params[0].chainId));
          }

          return p.then(function () {
            return webconnector.sendCustomRequest(payload);
          }).then(function (result) {
            fn(null, result);
          }).catch(function (err) {
            fn(err, null);
          });
        } else if (payload.method === 'eth_accounts') {
          // call accounts
          return p.then(function () {
            var accounts = null;

            if (webconnector && webconnector.session) {
              accounts = webconnector.session.accounts;
            }

            getCallback(payload, callback)(null, accounts || []);
          }).catch(getCallback(payload, callback));
        }
      } else {
        // normal call
        return p.then(function () {
          _this3._sendAsync(payload, callback);
        }).catch(function (error) {
          callback(new Error("Invalid connection ".concat(error)));
        });
      }
    }
    /**
     * Synchronously tries to make Http request
     *
     * @method isConnected
     * @return {Boolean} returns true if request haven't failed. Otherwise false
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      if (webconnector && webconnector.connected) {
        return true;
      }

      return false;
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (webconnector && webconnector.connected) {
        webconnector.killSession();
      }
    }
  }]);
  return WalletConnectProvider;
}();

exports.default = WalletConnectProvider;